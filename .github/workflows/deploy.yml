name: Deploy WordPress to AWS

on:
  push:
    branches: [master, main]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    env:
      S3_BUCKET: abdullatif-app
      ASG_NAME: abdullatif-asg
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
        
      - name: Create build package
        run: |
          DATE=$(date +%Y%m%d_%H%M%S)
          PACKAGE_NAME="app_$DATE.tar.gz"
          
          # Create a clean directory structure
          TEMP_DIR="wordpress_build_$DATE"
          mkdir -p "$TEMP_DIR"
          
          # Copy files to temp directory with exclusions
          rsync -av \
            --exclude='.git/' \
            --exclude='.github/' \
            --exclude='.gitignore' \
            --exclude='wp-config.php' \
            --exclude='wp-content/uploads/' \
            --exclude='node_modules/' \
            --exclude='*.log' \
            --exclude='.DS_Store' \
            --exclude='Thumbs.db' \
            ./ "$TEMP_DIR/"
          
          # Create tar archive from the clean directory
          tar -czf "$PACKAGE_NAME" -C "$TEMP_DIR" .
          
          # Verify the archive
          tar -tzf "$PACKAGE_NAME" | head -10
          
          # Cleanup temp directory
          rm -rf "$TEMP_DIR"
          
          echo "PACKAGE_NAME=$PACKAGE_NAME" >> $GITHUB_ENV
          
          # Display package info
          ls -lh "$PACKAGE_NAME"
        
      - name: Upload to S3
        run: |
          echo "üì¶ Uploading $PACKAGE_NAME to S3..."
          aws s3 cp "$PACKAGE_NAME" s3://$S3_BUCKET/builds/ --storage-class STANDARD_IA
          
          # Verify upload
          aws s3 ls s3://$S3_BUCKET/builds/ | grep "$PACKAGE_NAME"
          
          echo "S3_PATH=s3://$S3_BUCKET/builds/$PACKAGE_NAME" >> $GITHUB_ENV
          echo "‚úÖ Package uploaded successfully"
        
      - name: Get Auto Scaling Group Instances
        id: get-instances
        run: |
          echo "üîç Finding instances in Auto Scaling Group..."
          
          # Get healthy instances from ASG
          INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names $ASG_NAME \
            --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].InstanceId' \
            --output text)
          
          if [ -z "$INSTANCE_IDS" ]; then
            echo "‚ùå No healthy instances found in Auto Scaling Group!"
            exit 1
          fi
          
          echo "INSTANCE_IDS=$INSTANCE_IDS" >> $GITHUB_ENV
          echo "‚úÖ Found healthy instances: $INSTANCE_IDS"
          
          # Get instance details
          for INSTANCE_ID in $INSTANCE_IDS; do
            PRIVATE_IP=$(aws ec2 describe-instances \
              --instance-ids "$INSTANCE_ID" \
              --query 'Reservations[0].Instances[0].PrivateIpAddress' \
              --output text)
            echo "   Instance $INSTANCE_ID: $PRIVATE_IP"
          done
        
      - name: Create deployment script
        env:
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_HOST: ${{ secrets.DB_HOST }}
        run: |
          echo "üìù Creating deployment script..."
          
          cat > deploy-script.sh << 'DEPLOY_SCRIPT'
          #!/bin/bash
          set -e
          
          TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
          echo "[$TIMESTAMP] Starting deployment of $PACKAGE_NAME on $(hostname)"
          
          # Check AWS CLI and credentials
          echo "[$TIMESTAMP] Checking AWS configuration..."
          aws --version || echo "AWS CLI not found"
          aws sts get-caller-identity || echo "AWS credentials not configured"
          
          # List S3 bucket contents to test access
          echo "[$TIMESTAMP] Testing S3 access..."
          aws s3 ls s3://$S3_BUCKET/builds/ | head -5 || echo "Cannot access S3 bucket"
          
          # Create backup
          BACKUP_DIR="/tmp/wp_backup_$(date +%s)"
          echo "[$TIMESTAMP] Creating backup at $BACKUP_DIR"
          sudo cp -r /var/www/html "$BACKUP_DIR" || echo "Warning: Backup failed"
          
          # Download package from S3
          echo "[$TIMESTAMP] Downloading package from S3..."
          echo "[$TIMESTAMP] Attempting to download: s3://$S3_BUCKET/builds/$PACKAGE_NAME"
          
          if ! aws s3 cp "s3://$S3_BUCKET/builds/$PACKAGE_NAME" /tmp/; then
            echo "[$TIMESTAMP] ERROR: Failed to download package from S3"
            echo "[$TIMESTAMP] Checking if file exists in S3..."
            aws s3api head-object --bucket $S3_BUCKET --key "builds/$PACKAGE_NAME" || echo "File does not exist in S3"
            echo "[$TIMESTAMP] Current IAM identity:"
            aws sts get-caller-identity || echo "Cannot get IAM identity"
            echo "[$TIMESTAMP] Available files in S3 bucket:"
            aws s3 ls s3://$S3_BUCKET/builds/ | tail -10 || echo "Cannot list S3 bucket"
            exit 1
          fi
          
          echo "[$TIMESTAMP] Package downloaded successfully: $(ls -lh /tmp/$PACKAGE_NAME)"
          
          # Extract package
          EXTRACT_DIR="/tmp/app_extract_$(date +%s)"
          mkdir -p "$EXTRACT_DIR"
          echo "[$TIMESTAMP] Extracting package..."
          tar -xzf "/tmp/$PACKAGE_NAME" -C "$EXTRACT_DIR" || { echo "[$TIMESTAMP] ERROR: Failed to extract package"; exit 1; }
          
          # Verify WordPress files
          if [ ! -f "$EXTRACT_DIR/index.php" ]; then
            echo "[$TIMESTAMP] ERROR: WordPress files not found in package"
            echo "[$TIMESTAMP] Contents of extracted directory:"
            ls -la "$EXTRACT_DIR" | head -10
            exit 1
          fi
          
          echo "[$TIMESTAMP] WordPress files verified successfully"
          
          # Configure database settings if wp-config.php doesn't exist
          if [ ! -f "/var/www/html/wp-config.php" ]; then
            echo "[$TIMESTAMP] Creating wp-config.php with database settings..."
            cat > /tmp/wp-config.php << WPCONFIG
          <?php
          define('DB_NAME', '$DB_NAME');
          define('DB_USER', '$DB_USER');
          define('DB_PASSWORD', '$DB_PASSWORD');
          define('DB_HOST', '$DB_HOST');
          define('DB_CHARSET', 'utf8');
          define('DB_COLLATE', '');
          
          \$table_prefix = 'wp_';
          define('WP_DEBUG', false);
          
          define('AUTH_KEY', 'put your unique phrase here');
          define('SECURE_AUTH_KEY', 'put your unique phrase here');
          define('LOGGED_IN_KEY', 'put your unique phrase here');
          define('NONCE_KEY', 'put your unique phrase here');
          define('AUTH_SALT', 'put your unique phrase here');
          define('SECURE_AUTH_SALT', 'put your unique phrase here');
          define('LOGGED_IN_SALT', 'put your unique phrase here');
          define('NONCE_SALT', 'put your unique phrase here');
          
          if (!defined('ABSPATH')) {
              define('ABSPATH', __DIR__ . '/');
          }
          
          require_once ABSPATH . 'wp-settings.php';
          WPCONFIG
            
            sudo mv /tmp/wp-config.php /var/www/html/wp-config.php
            echo "[$TIMESTAMP] wp-config.php created successfully"
          else
            echo "[$TIMESTAMP] wp-config.php already exists, skipping creation"
          fi
          
          # Stop Apache
          echo "[$TIMESTAMP] Stopping Apache..."
          sudo systemctl stop apache2 || { echo "[$TIMESTAMP] WARNING: Failed to stop Apache"; }
          
          # Sync files
          echo "[$TIMESTAMP] Syncing files..."
          sudo rsync -av --delete --exclude="wp-config.php" --exclude="wp-content/uploads/" --exclude=".git/" --exclude=".gitignore" "$EXTRACT_DIR/" /var/www/html/ || { echo "[$TIMESTAMP] ERROR: Failed to sync files"; exit 1; }
          
          # Fix permissions
          echo "[$TIMESTAMP] Setting permissions..."
          sudo chown -R www-data:www-data /var/www/html/
          sudo find /var/www/html/ -type d -exec chmod 755 {} \;
          sudo find /var/www/html/ -type f -exec chmod 644 {} \;
          
          # Secure wp-config
          if [ -f "/var/www/html/wp-config.php" ]; then
            sudo chmod 600 /var/www/html/wp-config.php
            sudo chown www-data:www-data /var/www/html/wp-config.php
          fi
          
          # Fix uploads permissions
          if [ -d "/var/www/html/wp-content/uploads" ]; then
            sudo chown -R www-data:www-data /var/www/html/wp-content/uploads/
            sudo chmod -R 755 /var/www/html/wp-content/uploads/
          fi
          
          # Start Apache
          echo "[$TIMESTAMP] Starting Apache..."
          sudo systemctl start apache2 || { echo "[$TIMESTAMP] ERROR: Failed to start Apache"; exit 1; }
          
          # Verify Apache is running
          if ! sudo systemctl is-active --quiet apache2; then
            echo "[$TIMESTAMP] ERROR: Apache is not running after start"
            sudo systemctl status apache2
            exit 1
          fi
          
          # Cleanup
          rm -rf "/tmp/$PACKAGE_NAME" "$EXTRACT_DIR"
          sudo rm -rf "$BACKUP_DIR" 2>/dev/null || true
          
          echo "[$TIMESTAMP] ‚úÖ Deployment completed successfully on $(hostname)"
          
          # Health check
          sleep 3
          if curl -s -f "http://localhost/" >/dev/null 2>&1; then
            echo "[$TIMESTAMP] ‚úÖ Health check passed"
          else
            echo "[$TIMESTAMP] ‚ö†Ô∏è Health check failed, but deployment completed"
            curl -s -I "http://localhost/" || echo "Cannot connect to localhost"
          fi
          DEPLOY_SCRIPT
          
          # Upload script to S3
          SCRIPT_NAME="deploy-script-$(date +%s).sh"
          aws s3 cp deploy-script.sh s3://$S3_BUCKET/scripts/$SCRIPT_NAME
          echo "SCRIPT_NAME=$SCRIPT_NAME" >> $GITHUB_ENV
          echo "‚úÖ Deployment script uploaded to S3"
      
      - name: Deploy to instances
        env:
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_HOST: ${{ secrets.DB_HOST }}
        run: |
          echo "üöÄ Starting deployment to instances..."
          
          SUCCESS_COUNT=0
          TOTAL_INSTANCES=$(echo $INSTANCE_IDS | wc -w)
          
          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "üöÄ Deploying to instance: $INSTANCE_ID"
            
            # Send command via SSM - download and execute script from S3
            COMMAND_ID=$(aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters commands="[
                \"export DB_NAME='$DB_NAME'\",
                \"export DB_USER='$DB_USER'\",
                \"export DB_PASSWORD='$DB_PASSWORD'\",
                \"export DB_HOST='$DB_HOST'\",
                \"export S3_BUCKET='$S3_BUCKET'\",
                \"export PACKAGE_NAME='$PACKAGE_NAME'\",
                \"aws s3 cp s3://$S3_BUCKET/scripts/$SCRIPT_NAME /tmp/deploy.sh\",
                \"chmod +x /tmp/deploy.sh\",
                \"/tmp/deploy.sh\",
                \"rm -f /tmp/deploy.sh\"
              ]" \
              --timeout-seconds 900 \
              --output text \
              --query 'Command.CommandId')
            
            echo "   Command ID: $COMMAND_ID"
            
            # Wait for completion
            echo "   ‚è≥ Waiting for deployment to complete..."
            aws ssm wait command-executed \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --cli-read-timeout 660 || true
            
            # Check status
            COMMAND_STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text)
            
            if [ "$COMMAND_STATUS" = "Success" ]; then
              echo "   ‚úÖ Deployment successful on $INSTANCE_ID"
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            else
              echo "   ‚ùå Deployment failed on $INSTANCE_ID"
              
              # Get error details
              echo "   üìã Error Output:"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardErrorContent' \
                --output text | head -20
              
              echo "   üìã Standard Output:"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text | tail -20
            fi
          done
          
          # Cleanup script from S3
          aws s3 rm s3://$S3_BUCKET/scripts/$SCRIPT_NAME || true
          
          echo ""
          echo "üìä Deployment Summary:"
          echo "   Total instances: $TOTAL_INSTANCES"
          echo "   Successful: $SUCCESS_COUNT"
          echo "   Failed: $((TOTAL_INSTANCES - SUCCESS_COUNT))"
          
          if [ $SUCCESS_COUNT -eq 0 ]; then
            echo "‚ùå All deployments failed!"
            exit 1
          elif [ $SUCCESS_COUNT -lt $TOTAL_INSTANCES ]; then
            echo "‚ö†Ô∏è Partial deployment completed"
            exit 1
          else
            echo "‚úÖ All deployments completed successfully!"
          fi
        
      # - name: Trigger Instance Refresh
      #   if: success()
      #   run: |
      #     echo "üîÑ Triggering Auto Scaling Group instance refresh..."
          
      #     REFRESH_ID=$(aws autoscaling start-instance-refresh \
      #       --auto-scaling-group-name $ASG_NAME \
      #       --preferences '{"MinHealthyPercentage": 90, "InstanceWarmup": 300}' \
      #       --query 'InstanceRefreshId' \
      #       --output text)
          
      #     echo " Instance refresh started with ID: $REFRESH_ID "
      #     echo "This will gradually replace instances with the updated launch template."
      #     echo "Monitor progress in AWS Console or use: aws autoscaling describe-instance-refreshes --auto-scaling-group-name $ASG_NAME"
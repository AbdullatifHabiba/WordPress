name: Deploy WordPress to AWS

on:
  push:
    branches: [master, main]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    env:
      S3_BUCKET: abdullatif-app
      ASG_NAME: abdullatif-asg
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
        
      - name: Create build package
        env:
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_HOST: ${{ secrets.DB_HOST }}
        run: |
          # Generate wp-config.php with secrets
          echo "Generating wp-config.php..."
          cat > wp-config.php << WPCONFIG
          <?php
          define('DB_NAME', '$DB_NAME');
          define('DB_USER', '$DB_USER');
          define('DB_PASSWORD', '$DB_PASSWORD');
          define('DB_HOST', '$DB_HOST');
          define('DB_CHARSET', 'utf8');
          define('DB_COLLATE', '');
          
          define('AUTH_KEY',         '$(openssl rand -base64 32)');
          define('SECURE_AUTH_KEY',  '$(openssl rand -base64 32)');
          define('LOGGED_IN_KEY',    '$(openssl rand -base64 32)');
          define('NONCE_KEY',        '$(openssl rand -base64 32)');
          define('AUTH_SALT',        '$(openssl rand -base64 32)');
          define('SECURE_AUTH_SALT', '$(openssl rand -base64 32)');
          define('LOGGED_IN_SALT',   '$(openssl rand -base64 32)');
          define('NONCE_SALT',       '$(openssl rand -base64 32)');
          
          \$table_prefix = 'wp_';
          define('WP_DEBUG', false);
          
          if (!defined('ABSPATH')) {
              define('ABSPATH', __DIR__ . '/');
          }
          
          require_once ABSPATH . 'wp-settings.php';
          WPCONFIG

          DATE=$(date +%Y%m%d_%H%M%S)
          PACKAGE_NAME="app_$DATE.tar.gz"
          
          # Create tar archive directly from current directory
          # Create tar archive in temporary directory to avoid "file changed as we read it"
          tar -czf "/tmp/$PACKAGE_NAME" \
            --exclude='.git' \
            --exclude='.github' \
            --exclude='.gitignore' \
            --exclude='wp-content/uploads/*' \
            --exclude='node_modules' \
            --exclude='*.log' \
            --exclude='.DS_Store' \
            --exclude='Thumbs.db' \
            --exclude='*.tar.gz' \
            .
          
          # Move package back to workspace
          mv "/tmp/$PACKAGE_NAME" .
          
          # Verify the archive structure
          echo "Archive contents (first 20 files):"
          tar -tzf "$PACKAGE_NAME" | head -20
          
          echo "PACKAGE_NAME=$PACKAGE_NAME" >> $GITHUB_ENV
          
          # Display package info
          ls -lh "$PACKAGE_NAME"
        
      - name: Upload to S3
        run: |
          echo "üì¶ Uploading $PACKAGE_NAME to S3..."
          aws s3 cp "$PACKAGE_NAME" s3://$S3_BUCKET/builds/ --storage-class STANDARD_IA
          
          # Upload as latest for self-healing
          aws s3 cp "$PACKAGE_NAME" s3://$S3_BUCKET/builds/latest.tar.gz --storage-class STANDARD_IA
          
          # Verify upload
          aws s3 ls s3://$S3_BUCKET/builds/ | grep "$PACKAGE_NAME"
          
          echo "S3_PATH=s3://$S3_BUCKET/builds/$PACKAGE_NAME" >> $GITHUB_ENV
          echo "‚úÖ Package uploaded successfully (including latest.tar.gz)"
        
      - name: Get Auto Scaling Group Instances
        id: get-instances
        run: |
          echo "üîç Finding instances in Auto Scaling Group..."
          
          # Get healthy instances from ASG
          INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names $ASG_NAME \
            --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].InstanceId' \
            --output text)
          
          if [ -z "$INSTANCE_IDS" ]; then
            echo "‚ùå No healthy instances found in Auto Scaling Group!"
            exit 1
          fi
          
          echo "INSTANCE_IDS=$INSTANCE_IDS" >> $GITHUB_ENV
          echo "‚úÖ Found healthy instances: $INSTANCE_IDS"
          
          # Get instance details
          for INSTANCE_ID in $INSTANCE_IDS; do
            PRIVATE_IP=$(aws ec2 describe-instances \
              --instance-ids "$INSTANCE_ID" \
              --query 'Reservations[0].Instances[0].PrivateIpAddress' \
              --output text)
            echo "   Instance $INSTANCE_ID: $PRIVATE_IP"
          done
        
      - name: Create deployment script
        env:
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_HOST: ${{ secrets.DB_HOST }}
        run: |
          echo "üìù Creating deployment script..."
          
          cat > deploy-script.sh << 'DEPLOY_SCRIPT'
          #!/bin/bash
          set -e
          
          TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
          echo "[$TIMESTAMP] Starting deployment of $PACKAGE_NAME on $(hostname)"
          
          # Create backup
          BACKUP_DIR="/tmp/wp_backup_$(date +%s)"
          echo "[$TIMESTAMP] Creating backup at $BACKUP_DIR"
          sudo cp -r /var/www/html "$BACKUP_DIR" || echo "Warning: Backup failed"
          
          # Download package from S3
          echo "[$TIMESTAMP] Downloading package from S3..."
          
          if ! aws s3 cp "s3://$S3_BUCKET/builds/$PACKAGE_NAME" /tmp/; then
            echo "[$TIMESTAMP] ERROR: Failed to download package from S3"
            exit 1
          fi
          
          echo "[$TIMESTAMP] Package downloaded: $(ls -lh /tmp/$PACKAGE_NAME)"
          
          # Extract package
          EXTRACT_DIR="/tmp/app_extract_$(date +%s)"
          mkdir -p "$EXTRACT_DIR"
          echo "[$TIMESTAMP] Extracting package..."
          tar -xzf "/tmp/$PACKAGE_NAME" -C "$EXTRACT_DIR" || { echo "[$TIMESTAMP] ERROR: Failed to extract"; exit 1; }
          
          # Check extracted structure
          echo "[$TIMESTAMP] Checking extracted files..."
          ls -la "$EXTRACT_DIR/" | head -10
          
          # Determine source directory (handle nested structure if present)
          if [ -f "$EXTRACT_DIR/index.php" ] && [ -f "$EXTRACT_DIR/wp-login.php" ]; then
            # Files are at root level (correct structure)
            SOURCE_DIR="$EXTRACT_DIR"
            echo "[$TIMESTAMP] Files extracted correctly at root level"
          elif [ -d "$EXTRACT_DIR/wordpress_build_"* ]; then
            # Files are nested (old package format)
            NESTED_DIR=$(find "$EXTRACT_DIR" -maxdepth 1 -type d -name "wordpress_build_*" | head -1)
            SOURCE_DIR="$NESTED_DIR"
            echo "[$TIMESTAMP] Files in nested directory: $SOURCE_DIR"
          else
            echo "[$TIMESTAMP] ERROR: Cannot find WordPress files"
            echo "[$TIMESTAMP] Directory contents:"
            ls -la "$EXTRACT_DIR/"
            exit 1
          fi
          
          # Verify WordPress files exist
          if [ ! -f "$SOURCE_DIR/wp-login.php" ]; then
            echo "[$TIMESTAMP] ERROR: WordPress core files not found"
            exit 1
          fi
          
          echo "[$TIMESTAMP] WordPress files verified at: $SOURCE_DIR"
          
          # Check for broken config from previous failed deployment
          if grep -q "'\$DB_NAME'" /var/www/html/wp-config.php 2>/dev/null; then
            echo "[$TIMESTAMP] Found broken configuration file, removing..."
            sudo rm /var/www/html/wp-config.php
          fi
          
          # Configure wp-config.php if it doesn't exist
          if [ ! -f "/var/www/html/wp-config.php" ]; then
            echo "[$TIMESTAMP] Creating wp-config.php..."
            cat > /tmp/wp-config.php << WPCONFIG
          <?php
          define('DB_NAME', '$DB_NAME');
          define('DB_USER', '$DB_USER');
          define('DB_PASSWORD', '$DB_PASSWORD');
          define('DB_HOST', '$DB_HOST');
          define('DB_CHARSET', 'utf8');
          define('DB_COLLATE', '');
          
          define('AUTH_KEY',         'put your unique phrase here');
          define('SECURE_AUTH_KEY',  'put your unique phrase here');
          define('LOGGED_IN_KEY',    'put your unique phrase here');
          define('NONCE_KEY',        'put your unique phrase here');
          define('AUTH_SALT',        'put your unique phrase here');
          define('SECURE_AUTH_SALT', 'put your unique phrase here');
          define('LOGGED_IN_SALT',   'put your unique phrase here');
          define('NONCE_SALT',       'put your unique phrase here');
          
          \$table_prefix = 'wp_';
          define('WP_DEBUG', false);
          
          if (!defined('ABSPATH')) {
              define('ABSPATH', __DIR__ . '/');
          }
          
          require_once ABSPATH . 'wp-settings.php';
          WPCONFIG
            
            sudo mv /tmp/wp-config.php /var/www/html/wp-config.php
          fi
          
          # Stop Apache
          echo "[$TIMESTAMP] Stopping Apache..."
          sudo systemctl stop apache2 || true
          
          # Sync files
          echo "[$TIMESTAMP] Syncing files from $SOURCE_DIR to /var/www/html..."
          sudo rsync -av --delete \
            --exclude="wp-config.php" \
            --exclude="wp-content/uploads/" \
            --exclude=".git/" \
            --exclude=".gitignore" \
            "$SOURCE_DIR/" /var/www/html/ || { echo "[$TIMESTAMP] ERROR: Failed to sync"; exit 1; }
          
          # Verify deployment
          echo "[$TIMESTAMP] Verifying WordPress files..."
          if [ ! -f "/var/www/html/wp-login.php" ]; then
            echo "[$TIMESTAMP] ERROR: WordPress files not deployed correctly"
            ls -la /var/www/html/ | head -10
            exit 1
          fi
          
          # Fix permissions
          echo "[$TIMESTAMP] Setting permissions..."
          sudo chown -R www-data:www-data /var/www/html/
          sudo find /var/www/html/ -type d -exec chmod 755 {} \;
          sudo find /var/www/html/ -type f -exec chmod 644 {} \;
          
          # Secure wp-config
          if [ -f "/var/www/html/wp-config.php" ]; then
            sudo chmod 600 /var/www/html/wp-config.php
            sudo chown www-data:www-data /var/www/html/wp-config.php
          fi
          
          # Fix uploads permissions (EFS mount)
          if [ -d "/var/www/html/wp-content/uploads" ]; then
            sudo chown -R www-data:www-data /var/www/html/wp-content/uploads/
            sudo chmod -R 755 /var/www/html/wp-content/uploads/
          fi
          
          # Start Apache
          echo "[$TIMESTAMP] Starting Apache..."
          sudo systemctl start apache2 || { echo "[$TIMESTAMP] ERROR: Failed to start Apache"; exit 1; }
          
          # Verify Apache is running
          if ! sudo systemctl is-active --quiet apache2; then
            echo "[$TIMESTAMP] ERROR: Apache is not running"
            sudo systemctl status apache2
            exit 1
          fi
          
          # Cleanup
          rm -rf "/tmp/$PACKAGE_NAME" "$EXTRACT_DIR"
          sudo rm -rf "$BACKUP_DIR" 2>/dev/null || true
          
          echo "[$TIMESTAMP] ‚úÖ Deployment completed successfully on $(hostname)"
          
          # Health check
          sleep 3
          if curl -s -f "http://localhost/" >/dev/null 2>&1; then
            echo "[$TIMESTAMP] ‚úÖ Health check passed"
          else
            echo "[$TIMESTAMP] ‚ö†Ô∏è Health check warning"
          fi
          
          # Show deployed files
          echo "[$TIMESTAMP] Deployed WordPress files:"
          ls -la /var/www/html/ | head -15
          DEPLOY_SCRIPT
          
          # Upload script to S3
          SCRIPT_NAME="deploy-script-$(date +%s).sh"
          aws s3 cp deploy-script.sh s3://$S3_BUCKET/scripts/$SCRIPT_NAME
          aws s3 cp deploy-script.sh s3://$S3_BUCKET/scripts/latest-deploy.sh
          echo "SCRIPT_NAME=$SCRIPT_NAME" >> $GITHUB_ENV
          echo "‚úÖ Deployment script uploaded to S3"
      
      - name: Deploy to instances
        env:
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_HOST: ${{ secrets.DB_HOST }}
        run: |
          echo "üöÄ Starting deployment to instances..."
          
          SUCCESS_COUNT=0
          TOTAL_INSTANCES=$(echo $INSTANCE_IDS | wc -w)
          
          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "üöÄ Deploying to instance: $INSTANCE_ID"
            
            COMMAND_ID=$(aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters commands="[
                \"export DB_NAME='$DB_NAME'\",
                \"export DB_USER='$DB_USER'\",
                \"export DB_PASSWORD='$DB_PASSWORD'\",
                \"export DB_HOST='$DB_HOST'\",
                \"export S3_BUCKET='$S3_BUCKET'\",
                \"export PACKAGE_NAME='$PACKAGE_NAME'\",
                \"aws s3 cp s3://$S3_BUCKET/scripts/$SCRIPT_NAME /tmp/deploy.sh\",
                \"chmod +x /tmp/deploy.sh\",
                \"/tmp/deploy.sh\",
                \"rm -f /tmp/deploy.sh\"
              ]" \
              --timeout-seconds 900 \
              --output text \
              --query 'Command.CommandId')
            
            echo "   Command ID: $COMMAND_ID"
            echo "   ‚è≥ Waiting for deployment..."
            
            aws ssm wait command-executed \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --cli-read-timeout 660 || true
            
            COMMAND_STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text)
            
            if [ "$COMMAND_STATUS" = "Success" ]; then
              echo "   ‚úÖ Success on $INSTANCE_ID"
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
              
              # Show last 10 lines of output
              echo "   üìã Output:"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text | tail -10
            else
              echo "   ‚ùå Failed on $INSTANCE_ID (Status: $COMMAND_STATUS)"
              
              echo "   üìã Error:"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardErrorContent' \
                --output text | head -20
            fi
          done
          
          aws s3 rm s3://$S3_BUCKET/scripts/$SCRIPT_NAME || true
          
          echo ""
          echo "üìä Deployment Summary:"
          echo "   Total: $TOTAL_INSTANCES | Success: $SUCCESS_COUNT | Failed: $((TOTAL_INSTANCES - SUCCESS_COUNT))"
          
          if [ $SUCCESS_COUNT -eq 0 ]; then
            echo "‚ùå All deployments failed!"
            exit 1
          elif [ $SUCCESS_COUNT -lt $TOTAL_INSTANCES ]; then
            echo "‚ö†Ô∏è Partial deployment"
            exit 1
          else
            echo "‚úÖ All deployments successful!"
          fi
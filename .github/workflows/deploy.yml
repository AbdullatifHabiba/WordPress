name: Deploy WordPress to AWS

on:
  push:
    branches: [master, main]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1
        
    - name: Create build package
      run: |
        DATE=$(date +%Y%m%d_%H%M%S)
        PACKAGE_NAME="app_$DATE.tar.gz"
        
        # Create a clean directory structure
        TEMP_DIR="wordpress_build_$DATE"
        mkdir -p "$TEMP_DIR"
        
        # Copy files to temp directory with exclusions
        rsync -av \
          --exclude='.git/' \
          --exclude='.github/' \
          --exclude='.gitignore' \
          --exclude='wp-config.php' \
          --exclude='wp-content/uploads/' \
          --exclude='node_modules/' \
          --exclude='*.log' \
          --exclude='.DS_Store' \
          --exclude='Thumbs.db' \
          ./ "$TEMP_DIR/"
        
        # Create tar archive from the clean directory
        tar -czf "$PACKAGE_NAME" -C "$TEMP_DIR" .
        
        # Verify the archive
        tar -tzf "$PACKAGE_NAME" | head -10
        
        # Cleanup temp directory
        rm -rf "$TEMP_DIR"
        
        echo "PACKAGE_NAME=$PACKAGE_NAME" >> $GITHUB_ENV
        
        # Display package info
        ls -lh "$PACKAGE_NAME"
        
    - name: Upload to S3
      run: |
        echo "üì¶ Uploading $PACKAGE_NAME to S3..."
        aws s3 cp "$PACKAGE_NAME" s3://abdu-app/builds/ --storage-class STANDARD_IA
        
        # Verify upload
        aws s3 ls s3://abdu-app/builds/ | grep "$PACKAGE_NAME"
        
        echo "S3_PATH=s3://abdu-app/builds/$PACKAGE_NAME" >> $GITHUB_ENV
        echo "‚úÖ Package uploaded successfully"
        
    - name: Get Auto Scaling Group Instances
      id: get-instances
      run: |
        echo "üîç Finding instances in Auto Scaling Group..."
        
        # Get healthy instances from ASG
        INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
          --auto-scaling-group-names Abdu-project-asg \
          --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].InstanceId' \
          --output text)
        
        if [ -z "$INSTANCE_IDS" ]; then
          echo "‚ùå No healthy instances found in Auto Scaling Group!"
          exit 1
        fi
        
        echo "INSTANCE_IDS=$INSTANCE_IDS" >> $GITHUB_ENV
        echo "‚úÖ Found healthy instances: $INSTANCE_IDS"
        
        # Get instance details
        for INSTANCE_ID in $INSTANCE_IDS; do
          PRIVATE_IP=$(aws ec2 describe-instances \
            --instance-ids "$INSTANCE_ID" \
            --query 'Reservations[0].Instances[0].PrivateIpAddress' \
            --output text)
          echo "   Instance $INSTANCE_ID: $PRIVATE_IP"
        done
        
    - name: Deploy to instances
      run: |
        echo "üöÄ Starting deployment to instances..."
        
        # Enhanced deployment script
        cat > deploy_script.sh << 'DEPLOY_EOF'
        #!/bin/bash
        set -euo pipefail  # Strict error handling
        
        PACKAGE_NAME="$1"
        TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
        
        echo "[$TIMESTAMP] Starting deployment of $PACKAGE_NAME on $(hostname)"
        
        # Create backup of current installation
        BACKUP_DIR="/tmp/wp_backup_$(date +%s)"
        echo "[$TIMESTAMP] Creating backup at $BACKUP_DIR"
        cp -r /var/www/html "$BACKUP_DIR" || echo "Warning: Backup failed"
        
        # Download package from S3
        echo "[$TIMESTAMP] Downloading package from S3..."
        aws s3 cp "s3://abdu-app/builds/$PACKAGE_NAME" /tmp/ --quiet
        
        if [ ! -f "/tmp/$PACKAGE_NAME" ]; then
          echo "[$TIMESTAMP] ERROR: Failed to download package"
          exit 1
        fi
        
        # Extract to temporary directory
        EXTRACT_DIR="/tmp/app_extract_$(date +%s)"
        mkdir -p "$EXTRACT_DIR"
        echo "[$TIMESTAMP] Extracting package..."
        tar -xzf "/tmp/$PACKAGE_NAME" -C "$EXTRACT_DIR"
        
        # Verify extraction
        if [ ! -f "$EXTRACT_DIR/index.php" ]; then
          echo "[$TIMESTAMP] ERROR: WordPress files not found in package"
          exit 1
        fi
        
        # Stop nginx temporarily to prevent file locks
        echo "[$TIMESTAMP] Stopping nginx..."
        systemctl stop nginx
        
        # Sync files to WordPress directory
        echo "[$TIMESTAMP] Syncing files..."
        rsync -av --delete \
          --exclude='wp-config.php' \
          --exclude='wp-content/uploads/' \
          --exclude='.git/' \
          --exclude='.gitignore' \
          "$EXTRACT_DIR/" /var/www/html/
        
        # Restore proper permissions
        echo "[$TIMESTAMP] Setting permissions..."
        chown -R nginx:nginx /var/www/html/
        find /var/www/html/ -type d -exec chmod 755 {} \;
        find /var/www/html/ -type f -exec chmod 644 {} \;
        
        # Secure wp-config.php if it exists
        if [ -f "/var/www/html/wp-config.php" ]; then
          chmod 600 /var/www/html/wp-config.php
          chown nginx:nginx /var/www/html/wp-config.php
        fi
        
        # Ensure uploads directory has correct permissions
        if [ -d "/var/www/html/wp-content/uploads" ]; then
          chown -R nginx:nginx /var/www/html/wp-content/uploads/
          chmod -R 755 /var/www/html/wp-content/uploads/
        fi
        
        # Start nginx
        echo "[$TIMESTAMP] Starting nginx..."
        systemctl start nginx
        
        # Verify nginx is running
        if ! systemctl is-active --quiet nginx; then
          echo "[$TIMESTAMP] ERROR: Failed to start nginx"
          # Attempt to restore from backup
          if [ -d "$BACKUP_DIR" ]; then
            echo "[$TIMESTAMP] Restoring from backup..."
            rm -rf /var/www/html
            mv "$BACKUP_DIR" /var/www/html
            systemctl start nginx
          fi
          exit 1
        fi
        
        # Cleanup
        rm -rf "/tmp/$PACKAGE_NAME" "$EXTRACT_DIR"
        rm -rf "$BACKUP_DIR" 2>/dev/null || true
        
        echo "[$TIMESTAMP] ‚úÖ Deployment completed successfully on $(hostname)"
        
        # Health check
        sleep 2
        if curl -s -f "http://localhost/health.php" >/dev/null 2>&1; then
          echo "[$TIMESTAMP] ‚úÖ Health check passed"
        else
          echo "[$TIMESTAMP] ‚ö†Ô∏è  Health check failed, but deployment completed"
        fi
        DEPLOY_EOF
        
        # Deploy to each instance
        SUCCESS_COUNT=0
        TOTAL_INSTANCES=$(echo $INSTANCE_IDS | wc -w)
        
        for INSTANCE_ID in $INSTANCE_IDS; do
          echo "üöÄ Deploying to instance: $INSTANCE_ID"
          
          # Send deployment command via SSM
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[
              'cat > /tmp/deploy.sh << '\\''SCRIPT_EOF'\\''',
              '$(cat deploy_script.sh | sed "s/'/'\\\\''/g")',
              'SCRIPT_EOF',
              'chmod +x /tmp/deploy.sh',
              '/tmp/deploy.sh \"$PACKAGE_NAME\" 2>&1 | tee /tmp/deployment.log',
              'DEPLOY_EXIT_CODE=\${PIPESTATUS[0]}',
              'echo \"Deployment exit code: \$DEPLOY_EXIT_CODE\"',
              'rm -f /tmp/deploy.sh',
              'exit \$DEPLOY_EXIT_CODE'
            ]" \
            --timeout-seconds 600 \
            --output text \
            --query 'Command.CommandId')
          
          echo "   Command ID: $COMMAND_ID"
          
          # Wait for command to complete
          echo "   ‚è≥ Waiting for deployment to complete..."
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --cli-read-timeout 660 \
            --cli-connect-timeout 60 || true
          
          # Check command status
          COMMAND_STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query 'Status' \
            --output text)
          
          if [ "$COMMAND_STATUS" = "Success" ]; then
            echo "   ‚úÖ Deployment successful on $INSTANCE_ID"
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
          else
            echo "   ‚ùå Deployment failed on $INSTANCE_ID"
            # Get error output
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'StandardErrorContent' \
              --output text | head -20
          fi
        done
        
        echo ""
        echo "üìä Deployment Summary:"
        echo "   Total instances: $TOTAL_INSTANCES"
        echo "   Successful deployments: $SUCCESS_COUNT"
        echo "   Failed deployments: $((TOTAL_INSTANCES - SUCCESS_COUNT))"
        
        if [ $SUCCESS_COUNT -eq 0 ]; then
          echo "‚ùå All deployments failed!"
          exit 1
        elif [ $SUCCESS_COUNT -lt $TOTAL_INSTANCES ]; then
          echo "‚ö†Ô∏è  Partial deployment completed"
          exit 1
        else
          echo "‚úÖ All deployments completed successfully!"
        fi
        
    - name: Verify deployment
      run: |
        echo "üîç Verifying deployment across all instances..."
        
        # Wait for services to stabilize
        sleep 15
        
        HEALTHY_INSTANCES=0
        
        for INSTANCE_ID in $INSTANCE_IDS; do
          echo "   Checking instance $INSTANCE_ID..."
          
          # Get instance public IP
          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids "$INSTANCE_ID" \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          
          if [ "$PUBLIC_IP" != "None" ] && [ "$PUBLIC_IP" != "null" ]; then
            # Test health endpoint with timeout
            if timeout 10 curl -s -f "http://$PUBLIC_IP/health.php" | grep -q "OK\|phpinfo"; then
              echo "   ‚úÖ Instance $INSTANCE_ID ($PUBLIC_IP) is healthy"
              HEALTHY_INSTANCES=$((HEALTHY_INSTANCES + 1))
            else
              echo "   ‚ùå Instance $INSTANCE_ID ($PUBLIC_IP) health check failed"
              
              # Try to get more info
              timeout 5 curl -s -I "http://$PUBLIC_IP/" | head -5 || echo "     Connection failed"
            fi
          else
            echo "   ‚ö†Ô∏è  Instance $INSTANCE_ID has no public IP"
          fi
        done
        
        TOTAL_INSTANCES=$(echo $INSTANCE_IDS | wc -w)
        
        echo ""
        echo "üè• Health Check Summary:"
        echo "   Healthy instances: $HEALTHY_INSTANCES/$TOTAL_INSTANCES"
        
        if [ $HEALTHY_INSTANCES -eq 0 ]; then
          echo "‚ùå No instances are responding to health checks!"
          exit 1
        elif [ $HEALTHY_INSTANCES -lt $TOTAL_INSTANCES ]; then
          echo "‚ö†Ô∏è  Some instances are not healthy"
        else
          echo "‚úÖ All instances are healthy!"
        fi
        
        echo ""
        echo "üéâ Deployment pipeline completed!"
        echo "üì¶ Package: $PACKAGE_NAME"
        echo "üïí Timestamp: $(date)"
        
     
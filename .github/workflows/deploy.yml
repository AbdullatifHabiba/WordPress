name: Deploy WordPress to AWS

on:
  push:
    branches: [master, main]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
        
      - name: Create build package
        run: |
          DATE=$(date +%Y%m%d_%H%M%S)
          PACKAGE_NAME="app_$DATE.tar.gz"
          
          # Create a clean directory structure
          TEMP_DIR="wordpress_build_$DATE"
          mkdir -p "$TEMP_DIR"
          
          # Copy files to temp directory with exclusions
          rsync -av \
            --exclude='.git/' \
            --exclude='.github/' \
            --exclude='.gitignore' \
            --exclude='wp-config.php' \
            --exclude='wp-content/uploads/' \
            --exclude='node_modules/' \
            --exclude='*.log' \
            --exclude='.DS_Store' \
            --exclude='Thumbs.db' \
            ./ "$TEMP_DIR/"
          
          # Create tar archive from the clean directory
          tar -czf "$PACKAGE_NAME" -C "$TEMP_DIR" .
          
          # Verify the archive
          tar -tzf "$PACKAGE_NAME" | head -10
          
          # Cleanup temp directory
          rm -rf "$TEMP_DIR"
          
          echo "PACKAGE_NAME=$PACKAGE_NAME" >> $GITHUB_ENV
          
          # Display package info
          ls -lh "$PACKAGE_NAME"
        
      - name: Upload to S3
        run: |
          echo "üì¶ Uploading $PACKAGE_NAME to S3..."
          aws s3 cp "$PACKAGE_NAME" s3://abdu-app/builds/ --storage-class STANDARD_IA
          
          # Verify upload
          aws s3 ls s3://abdu-app/builds/ | grep "$PACKAGE_NAME"
          
          echo "S3_PATH=s3://abdu-app/builds/$PACKAGE_NAME" >> $GITHUB_ENV
          echo "‚úÖ Package uploaded successfully"
        
      - name: Upload deployment script to S3
        run: |
          echo "üì§ Uploading deployment script to S3..."
          
          # Create deployment script
          cat > deploy.sh << 'DEPLOY_EOF'
          #!/bin/bash
          set -euo pipefail

          PACKAGE_NAME="$1"
          TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

          echo "[$TIMESTAMP] Starting deployment of $PACKAGE_NAME on $(hostname)"

          # Create backup
          BACKUP_DIR="/tmp/wp_backup_$(date +%s)"
          echo "[$TIMESTAMP] Creating backup at $BACKUP_DIR"
          cp -r /var/www/html "$BACKUP_DIR" || echo "Warning: Backup failed"

          # Download package
          echo "[$TIMESTAMP] Downloading package from S3..."
          aws s3 cp "s3://abdu-app/builds/$PACKAGE_NAME" /tmp/ --quiet

          if [ ! -f "/tmp/$PACKAGE_NAME" ]; then
            echo "[$TIMESTAMP] ERROR: Failed to download package"
            exit 1
          fi

          # Extract
          EXTRACT_DIR="/tmp/app_extract_$(date +%s)"
          mkdir -p "$EXTRACT_DIR"
          echo "[$TIMESTAMP] Extracting package..."
          tar -xzf "/tmp/$PACKAGE_NAME" -C "$EXTRACT_DIR"

          # Verify
          if [ ! -f "$EXTRACT_DIR/index.php" ]; then
            echo "[$TIMESTAMP] ERROR: WordPress files not found in package"
            exit 1
          fi

          # Stop nginx
          echo "[$TIMESTAMP] Stopping nginx..."
          systemctl stop nginx

          # Sync files
          echo "[$TIMESTAMP] Syncing files..."
          rsync -av --delete \
            --exclude='wp-config.php' \
            --exclude='wp-content/uploads/' \
            --exclude='.git/' \
            --exclude='.gitignore' \
            "$EXTRACT_DIR/" /var/www/html/

          # Fix permissions
          echo "[$TIMESTAMP] Setting permissions..."
          chown -R nginx:nginx /var/www/html/
          find /var/www/html/ -type d -exec chmod 755 {} \;
          find /var/www/html/ -type f -exec chmod 644 {} \;

          # Secure wp-config
          if [ -f "/var/www/html/wp-config.php" ]; then
            chmod 600 /var/www/html/wp-config.php
            chown nginx:nginx /var/www/html/wp-config.php
          fi

          # Fix uploads permissions
          if [ -d "/var/www/html/wp-content/uploads" ]; then
            chown -R nginx:nginx /var/www/html/wp-content/uploads/
            chmod -R 755 /var/www/html/wp-content/uploads/
          fi

          # Start nginx
          echo "[$TIMESTAMP] Starting nginx..."
          systemctl start nginx

          # Verify nginx
          if ! systemctl is-active --quiet nginx; then
            echo "[$TIMESTAMP] ERROR: Failed to start nginx"
            if [ -d "$BACKUP_DIR" ]; then
              echo "[$TIMESTAMP] Restoring from backup..."
              rm -rf /var/www/html
              mv "$BACKUP_DIR" /var/www/html
              systemctl start nginx
            fi
            exit 1
          fi

          # Cleanup
          rm -rf "/tmp/$PACKAGE_NAME" "$EXTRACT_DIR"
          rm -rf "$BACKUP_DIR" 2>/dev/null || true

          echo "[$TIMESTAMP] ‚úÖ Deployment completed successfully on $(hostname)"

          # Health check
          sleep 2
          if curl -s -f "http://localhost/health.php" >/dev/null 2>&1; then
            echo "[$TIMESTAMP] ‚úÖ Health check passed"
          else
            echo "[$TIMESTAMP] ‚ö†Ô∏è Health check failed, but deployment completed"
          fi
          DEPLOY_EOF
          
          # Upload script to S3
          aws s3 cp deploy.sh s3://abdu-app/scripts/deploy.sh
          echo "‚úÖ Deployment script uploaded to S3"
        
      - name: Get Auto Scaling Group Instances
        id: get-instances
        run: |
          echo "üîç Finding instances in Auto Scaling Group..."
          
          # Get healthy instances from ASG
          INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names Abdu-project-asg \
            --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].InstanceId' \
            --output text)
          
          if [ -z "$INSTANCE_IDS" ]; then
            echo "‚ùå No healthy instances found in Auto Scaling Group!"
            exit 1
          fi
          
          echo "INSTANCE_IDS=$INSTANCE_IDS" >> $GITHUB_ENV
          echo "‚úÖ Found healthy instances: $INSTANCE_IDS"
          
          # Get instance details
          for INSTANCE_ID in $INSTANCE_IDS; do
            PRIVATE_IP=$(aws ec2 describe-instances \
              --instance-ids "$INSTANCE_ID" \
              --query 'Reservations[0].Instances[0].PrivateIpAddress' \
              --output text)
            echo "   Instance $INSTANCE_ID: $PRIVATE_IP"
          done
        
      - name: Deploy to instances
        run: |
          echo "üöÄ Starting deployment to instances..."
          
          SUCCESS_COUNT=0
          TOTAL_INSTANCES=$(echo $INSTANCE_IDS | wc -w)
          
          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "üöÄ Deploying to instance: $INSTANCE_ID"
            
            # Simple SSM command that downloads and runs the script
            COMMAND_ID=$(aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters 'commands=[
                "echo Starting deployment process...",
                "aws s3 cp s3://abdu-app/scripts/deploy.sh /tmp/deploy.sh",
                "chmod +x /tmp/deploy.sh",
                "/tmp/deploy.sh '"$PACKAGE_NAME"'",
                "DEPLOY_EXIT_CODE=$?",
                "echo Deployment exit code: $DEPLOY_EXIT_CODE",
                "rm -f /tmp/deploy.sh",
                "exit $DEPLOY_EXIT_CODE"
              ]' \
              --timeout-seconds 600 \
              --output text \
              --query 'Command.CommandId')
            
            echo "   Command ID: $COMMAND_ID"
            
            # Wait for completion
            echo "   ‚è≥ Waiting for deployment to complete..."
            aws ssm wait command-executed \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --cli-read-timeout 660 || true
            
            # Check status
            COMMAND_STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text)
            
            if [ "$COMMAND_STATUS" = "Success" ]; then
              echo "   ‚úÖ Deployment successful on $INSTANCE_ID"
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            else
              echo "   ‚ùå Deployment failed on $INSTANCE_ID"
              
              # Get error details
              echo "   üìã Error Output:"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardErrorContent' \
                --output text | head -10
              
              echo "   üìã Standard Output:"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text | tail -10
            fi
          done
          
          echo ""
          echo "üìä Deployment Summary:"
          echo "   Total instances: $TOTAL_INSTANCES"
          echo "   Successful: $SUCCESS_COUNT"
          echo "   Failed: $((TOTAL_INSTANCES - SUCCESS_COUNT))"
          
          if [ $SUCCESS_COUNT -eq 0 ]; then
            echo "‚ùå All deployments failed!"
            exit 1
          elif [ $SUCCESS_COUNT -lt $TOTAL_INSTANCES ]; then
            echo "‚ö†Ô∏è Partial deployment completed"
            exit 1
          else
            echo "‚úÖ All deployments completed successfully!"
          fi
        
      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment across all instances..."
          
          # Wait for services to stabilize
          sleep 15
          
          HEALTHY_INSTANCES=0
          
          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "   Checking instance $INSTANCE_ID..."
            
            # Get instance public IP
            PUBLIC_IP=$(aws ec2 describe-instances \
              --instance-ids "$INSTANCE_ID" \
              --query 'Reservations[0].Instances[0].PublicIpAddress' \
              --output text)
            
            if [ "$PUBLIC_IP" != "None" ] && [ "$PUBLIC_IP" != "null" ]; then
              # Test health endpoint with timeout
              if timeout 10 curl -s -f "http://$PUBLIC_IP/health.php" | grep -q "OK\|phpinfo"; then
                echo "   ‚úÖ Instance $INSTANCE_ID ($PUBLIC_IP) is healthy"
                HEALTHY_INSTANCES=$((HEALTHY_INSTANCES + 1))
              else
                echo "   ‚ùå Instance $INSTANCE_ID ($PUBLIC_IP) health check failed"
                
                # Try to get more info
                timeout 5 curl -s -I "http://$PUBLIC_IP/" | head -5 || echo "     Connection failed"
              fi
            else
              echo "   ‚ö†Ô∏è  Instance $INSTANCE_ID has no public IP"
            fi
          done
          
          TOTAL_INSTANCES=$(echo $INSTANCE_IDS | wc -w)
          
          echo ""
          echo "üè• Health Check Summary:"
          echo "   Healthy instances: $HEALTHY_INSTANCES/$TOTAL_INSTANCES"
          
          if [ $HEALTHY_INSTANCES -eq 0 ]; then
            echo "‚ùå No instances are responding to health checks!"
            exit 1
          elif [ $HEALTHY_INSTANCES -lt $TOTAL_INSTANCES ]; then
            echo "‚ö†Ô∏è Some instances are not healthy"
          else
            echo "‚úÖ All instances are healthy!"
          fi
          
          echo ""
          echo "üéâ Deployment pipeline completed!"
          echo "üì¶ Package: $PACKAGE_NAME"
          echo "üïí Timestamp: $(date)"